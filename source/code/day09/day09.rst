###########
进程管理   
###########

::

    第一课   编程基础
    第二课   内存管理
    第三课   文件系统
    第四课   进程管理
    第五课   信号处理
    第六课   进程通信
    第七课   网络通信
    第八课   线程管理
    第九课   线程同步
    第十课   综合案例
    ------------------

    一、基本概念
    1.进程与程序
    1)进程就是运行中的程序。一个运行着的程序，
    可能有多个进程。进程在操作系统中完成特定的任务。
    进程是一个内存的概念，就是内存中的一个数据块，
    其中包括代码和数据。
    2)程序是存储在磁盘上，
    包含可执行的机器指令和数据的静态实体。
    进程或任务是处于活动状态的程序。
    程序是一个文件的概念，其中包含了代码和数据。
    2.进程的分类
    1)交互进程：通过一个人机界面与用户交换信息。
    2)批量进程：在无人值守的情况下，
    集中执行一个复杂而且耗时的任务。
    3)守护进程(幽灵进程/精灵进程)
    3.查看进程
    1)简单形式
    $ ps
    以简略的格式显示当前用户拥有控制终端的进程信息。
    2)BSD风格常用选项
    $ ps axu
    a - 所有用户有控制终端的进程
    x - 包括无控制终端的进程
    u - 详尽方式显示
    w - 增加列宽
    3)SVR4风格常用选项
    $ ps -efl
    -e/-A - 所用用户的进程
    -a - 当前终端的进程
    -u 用户名/用户ID - 特定用户的进程
    -g 组名/组ID - 特定组的进程
    -f - 按完整格式显示
    -F - 按更完整格式显示
    -l - 按长格式显示
    4)进程信息列表
    USER/UID：进程的实际用户ID
    PID：进程ID
    %CPU/C：处理器使用率
    %MEM：内存使用率
    VSZ：占用虚拟内存大小（KB）
    RSS：占用半导体内存大小（KB）
    TTY：终端机次设备号，“?”表示无控制终端
    STAT/S：进程状态
      O - 就绪。等待被调度。
      R - 运行。正在被处理机执行。Linux下没有O状态，处于就绪状态
            的进程也用R表示。
      S - 可唤醒的睡眠。系统中断、获得资源，收到信号，都可被唤醒，
            转入运行状态。
      D - 不可唤醒的睡眠。只能被wake_up系统调用唤醒。
      T - 停止。收到SIGSTOP信号转入停止状态。
            收到SIGCONT信号重新转入运行状态。
      W - 等待内存分页。2.6版以后的Linux内核以取消此状态。
      X - 终止。死亡。不可见。  
      Z - 僵尸。进程已经终止，但其父进程尚未回收该进程的状态
                    （尸体）。
      < - 高优先级。
      N - 低优先级。
      L - 存在被锁入内存的分页。实时进程。
      s - 会话首进程。
      l - 多线程化的进程。
      + - 在前台进程组中的进程。
    START/STIME：进程开始时间
    COMMAND/CMD：进程启动命令
    F：进程标志，1 - 通过fork产生但是没有调用exec。
                         4 - 拥有超级用户权限。
    PPID：父进程的PID。
    NI：进程nice值，-20到19，衡量进程对处理器而言的友好程度。
           越小越友好。
    PRI：进程实际优先级。一个进程的实际优先级由两部分组成：
             静态优先级 = 80 + nice，60到99，值越小优先级越高
             动态优先级，系统内核可以根据进程表现进行奖惩。
             对于处理机消耗型进程，惩罚，降低优先级。
             对于I/O消耗型进程，奖励，提升优先级。
    ADDR：内核进程的起始地址。普通进程显示“-”。
    SZ：虚拟内存页数。
    WCHAN：进程正在阻塞的系统调用。
    PSR：进程当前正在被哪个处理器执行。
    4.父进程、子进程、孤儿进程、僵尸进程
    1)在一个进程中通过特定的系统调用可以创建另一个进程，
    创建进程的进程就被成为父进程，被创建的进程被称为子进程。
    进程A创建进程B，进程B创建了进程C。
    A是B的父进程，B是C的父进程。
    C是B的子进程，B是A的子进程。
    内核进程(PID=0)
    ->init进程(PID=1)
        ->xinetd
            ->in.telnetd <- 远程用户登录
                ->login
                    ->bash
                        ->vi
                        ->gcc
                        ->a.out
                        ->...
    每个父进程可能会有1到多个子进程，
    但是每个子进程只有一个父进程――树状结构。
    2)父进程先于子进程结束，子进程就成为孤儿进程，
    同时被init进程收养，即成为init进程的子进程。
    3)子进程先于父进程结束，但是父进程没有及时回收子进程的状态（尸体），此时该子进程即为僵尸进程。
    如果父进程在结束前一直都没有回收子进程的尸体，该尸体就会被
    init进程回收。
    5.进程标识符（PID）
    1)系统中的每个进程都以一个唯一的标识号，即PID。
    2)任何时刻，不能存在PID相同的进程。进程一旦终止，而且没有成为
    僵尸，该进程的PID就可以被其它进程复用。
    3)延迟重用。
    pid_t getpid (void);
    获取调用进程的PID。永远不会失败。
    二、进程ID相关的函数：getxxxid
    #include <unistd.h>
    getpid   - 获取进程标识
    getppid - 获取父进程标识
    getuid   - 获取实际用户ID，即登录shell的用户ID
    getgid   - 获取实际组ID，即登录shell的组ID
    geteuid - 获取有效用户ID
    getegid - 获取有效组ID
    进程有效用户/组ID默认情况下，取自其实际用户/组ID。但是，
    如果该进程所对应的可执行文件带有设置用户/组ID位，那么该进程
    的有效用户/组ID，就取自可执行文件的用户/组。
    假设a.out文件的用户和组都是root，以tarena用户的身份登录系统，
    并执行a.out程序，其运行结果：
    实际用户ID：1000
    实际组ID：1000
    有效用户ID：1000
    有效组ID：1000
    以root修改a.out文件的权限：
    # chmod u+s a.out
    # chmod g+s a.out
    # ls -l a.out
    -rwsr-sr-x 1 root root ... a.out
    再次以tarena用户的身份登录系统，并执行a.out程序，其运行结果：
    实际用户ID：1000
    实际组ID：1000
    有效用户ID：0
    有效组ID：0
    三、fork
    #include <unistd.h>
    pid_t fork (void);
    1.创建一个子进程，失败返回-1。
    2.调用一次，返回两次。
    分别在父子进程中返回子进程的PID和0。
    利用该函数返回值的不同，
    分别父子进程编写处理代码。
    3.子进程是父进程的副本，
    子进程获得父进程的数据段和堆栈段（包括I/O流缓冲区）的拷贝，
    但是父子进程共享同一个代码段。
    4.fork函数被调用以后父子进程各自独立地运行，
    其被执行的先后顺序无法确定。
    某些UNIX实现，会先调度子进程。
    5.fork函数被调用以后父进程的文件描述符表，
    也会被复制一份给子进程，二者同一个文件表。
    6.如果当前线程数已经达到系统的最大线程数，
    或者当前用户的进程数已经达到该用户的最大进程数，
    那么fork函数会失败。
    $ cat /proc/sys/kernel/threads-max
    $ ulimit -u
    ioctl
    
    
