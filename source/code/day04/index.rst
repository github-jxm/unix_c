##############
内存管理 - d04  
##############

::

    回顾：
      环境变量和环境表的相关函数 - getenv() setenv() putenv() unsetenv() clearenv()
      Unix/Linux的内存管理 - C程序员能用的6个函数
       进程的内存空间划分：6个部分
        代码区、只读常量区、全局区、BSS段、堆、栈
       Unix/Linux内存管理机制 - 虚拟内存地址
        程序员目前接触都是 虚拟内存地址，是 地址的编号，本身不能存储任何的数据，需要做内存映射才能存储数据。内存映射就是把虚拟内存地址和 物理内存/硬盘文件 对应起来。内存的分配是以 字节作为基本单位，但内存映射 是以 内存页 作为基本单位，一个内存页 4096字节。虚拟内存地址在使用时会被分配，内存分配过程包括两步：
       1 分配虚拟内存地址(未使用的)
       2 映射物理内存/硬盘文件
    今天：
      关于 C程序员的基本功 - 操作字符串的代码 （超重点）
      6个函数 - malloc() free() sbrk() brk() mmap() munmap()
      malloc()函数分配的是堆区内存，在第一次申请内存时会映射33个内存页(申请的是小块内存，如果是大块内存会映射比申请的多一点的页数)，在33个内存页之内不会再次映射，只需要分配虚拟内存地址。
      malloc()除了分配申请的内存之外，还需要额外的空间去存储一些附加数据，比如：分配了多少字节，附加数据以双向链表的形式存在分配内存的前面，还会留出一些空白。因此，使用malloc()分配的内存时，不要超界使用，否则可能导致后面的内存出现问题。
      free()一定会释放虚拟内存地址，但不一定会 解除内存映射。最后的33页 free()不会解除映射，直到进程结束。free()不一定会擦除数据。
      sbrk()和brk()
        sbrk()和brk()是UC函数，因此机制和malloc()、free()完全不同。
        sbrk()和brk()依靠 系统维护的一个位置实现内存的分配和回收，sbrk()和brk()都可以 分配 也可以回收内存。但sbrk()更适合分配内存，brk()更适合回收。
        void* sbrk(int increment) 
         参数是一个整数，代表内存的增量，其实是位置移动的值
         参数为正数时，分配内存，返回分配内存的首地址
         参数为负数时，回收内存，返回没有实际意义
         参数为0时，不分配也不回收内存，取当前的位置
         返回移动之前的位置。如果出错，返回 -1。 
    
      作业：
        用sbrk()分配内存，用brk()回收内存方式 改良 brk.c代码。
        要求新建一个文件。
